#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import sys
import os
import socket
import re
import lzf
try:
    from PIL import Image
    from PIL import ImageDraw
    from PIL import ImageFont
    from PIL import ImageChops
except ImportError:
    print("%s depends on the Python Image Library, please install:" % sys.argv[0])
    print("pip3 install Pillow")
    sys.exit(0)

def rescale(val,maxval):
    return int(round(val * maxval / 255.0))

def rgb888_to_rgb565(r,g,b):
    rgb565 = (
        rescale(r, 31) << 11 |
        rescale(g, 63) << 5 |
        rescale(b, 31)
    )
    return rgb565

fileHeader = """\
/* Copyright 2020 QMK
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * This file was auto-generated by util/convert_gfx.py!
 */

"""

"""
Convert an image to a packed mono 4bpp byte array
"""
def image_to_mono4bpp(im):
    im = im.convert("RGB")
    image_bytes = im.tobytes("raw","R") # Create a byte array from the red channel of the input image
    image_bytes += b'\0' # Dummy value at the end for alignment
    image_bytes_len = len(image_bytes)

    # Convert 8bpp to packed 4bpp
    mono2array = []
    for x in range(int(image_bytes_len / 2)):
        mono2array.append(
            rescale(image_bytes[x*2+1], 15) << 4 |
            rescale(image_bytes[x*2+0], 15))

    return mono2array

"""
Convert an image to a packed mono 2bpp byte array
"""
def image_to_mono2bpp(im):
    im = im.convert("RGB")
    image_bytes = im.tobytes("raw","R") # Create a byte array from the red channel of the input image
    image_bytes += b'\0\0\0' # Dummy value at the end for alignment
    image_bytes_len = len(image_bytes)

    # Convert 8bpp to packed 2bpp
    mono2array = []
    for x in range(int(image_bytes_len / 4)):
        mono2array.append(
            rescale(image_bytes[x*4+3], 3) << 6 |
            rescale(image_bytes[x*4+2], 3) << 4 |
            rescale(image_bytes[x*4+1], 3) << 2 |
            rescale(image_bytes[x*4+0], 3))

    return mono2array

"""
Convert an image to a packed mono 1bpp byte array
"""
def image_to_mono1bpp(im):
    im = im.convert("RGB")
    image_bytes = im.tobytes("raw","R") # Create a byte array from the red channel of the input image
    image_bytes += b'\0\0\0\0\0\0\0' # Dummy value at the end for alignment
    image_bytes_len = len(image_bytes)

    # Convert 8bpp to packed 1bpp
    mono1array = []
    for x in range(int(image_bytes_len / 8)):
        mono1array.append(
            rescale(image_bytes[x*8+7], 1) << 7 |
            rescale(image_bytes[x*8+6], 1) << 6 |
            rescale(image_bytes[x*8+5], 1) << 5 |
            rescale(image_bytes[x*8+4], 1) << 4 |
            rescale(image_bytes[x*8+3], 1) << 3 |
            rescale(image_bytes[x*8+2], 1) << 2 |
            rescale(image_bytes[x*8+1], 1) << 1 |
            rescale(image_bytes[x*8+0], 1))

    return mono1array

"""
Convert an image to a rgb565 byte array
"""
def image_to_rgb565(im):
    im = im.convert("RGB")
    image_bytes = im.tobytes("raw","RGB") # Create a byte array in 24 bit RGB format from an image
    image_bytes_len = len(image_bytes)

    # Convert 24-bit RGB to 16-bit BGR
    rgb565array = []
    for x in range(int(image_bytes_len / 3)):
        r = image_bytes[x*3+0]
        g = image_bytes[x*3+1]
        b = image_bytes[x*3+2]
        rgb565 = rgb888_to_rgb565(r, g, b)
        rgb565array.append((rgb565 >> 8) & 0xFF)
        rgb565array.append(rgb565 & 0xFF)

    return rgb565array

"""
Measure the size of an image and return the coordinates of the (left, upper, right, lower) bounding box
"""
def measure(im, border=(0,0,0,0)):
    bg = Image.new(im.mode, im.size, border)
    diff = ImageChops.difference(im, bg)
    diff = ImageChops.add(diff, diff, 2.0, -100)
    return diff.getbbox()

"""
Convert the specified font to a pair of .c/.h C language lookup tables in BGR565 format
"""
def convert_graphic_to_c(graphic_fname, output_filename, compress, chunksize, fmt_rgb565, fmt_4bpp, fmt_2bpp, fmt_1bpp):
    print("Converting %s to gfx-%s.c/h" % (graphic_fname, output_filename))
    sane_name = re.sub(r"[^a-zA-Z0-9]", "_", output_filename)
    graphic_image = Image.open(graphic_fname)

    if compress == True:
        if chunksize < 64:
            raise Exception("Chunk size must be >= 64")
        if chunksize > 512:
            raise Exception("Chunk size must be <= 512")

    # Get image dimensions
    (width, height) = graphic_image.size

    # Convert image to rgb565 byte list
    if fmt_rgb565:
        graphic_data = image_to_rgb565(graphic_image)
        newline_counter = int(width * 2)
        image_format = "IMAGE_FORMAT_RGB565"
        format_name = "rgb565"
    elif fmt_4bpp:
        graphic_data = image_to_mono4bpp(graphic_image)
        newline_counter = int(width / 2)
        image_format = "IMAGE_FORMAT_MONO4BPP"
        format_name = "4bpp"
    elif fmt_2bpp:
        graphic_data = image_to_mono2bpp(graphic_image)
        newline_counter = int(width / 4)
        image_format = "IMAGE_FORMAT_MONO2BPP"
        format_name = "2bpp"
    elif fmt_1bpp:
        graphic_data = image_to_mono1bpp(graphic_image)
        newline_counter = int(width / 8)
        image_format = "IMAGE_FORMAT_MONO1BPP"
        format_name = "1bpp"

    # Generate the output filenames
    gfx_source_filename = "gfx-%s.c" % (output_filename)
    gfx_header_filename = "gfx-%s.h" % (output_filename)

    # Generate the C source file
    gfx_source_file = open(gfx_source_filename, "w")
    gfx_source_file.write(fileHeader)

    gfx_source_file.write("/* generated from %s */\n\n" % (graphic_fname))

    gfx_source_file.write("#include <stdint.h>\n")
    gfx_source_file.write("#include <qp.h>\n")
    gfx_source_file.write("#include <qp_internal.h>\n\n")
    gfx_source_file.write("// clang-format off\n\n")

    if compress == True:
        compressed_data = []
        compressed_chunk_offsets = []
        uncompressed_graphic_data = graphic_data.copy()
        while len(uncompressed_graphic_data) > 0:
            chunk_size = min(chunksize,len(uncompressed_graphic_data))
            uncompressed_chunk = uncompressed_graphic_data[0:chunk_size]
            uncompressed_graphic_data = uncompressed_graphic_data[chunk_size:]
            compressed = lzf.compress(bytes(uncompressed_chunk), int(len(uncompressed_chunk)*2))
            compressed_chunk_offsets.append((len(compressed_data),len(compressed))) # keep track of where this chunk starts
            compressed_data.extend(compressed)

        # Write out the compressed chunk offsets
        gfx_source_file.write("const uint32_t gfx_%s_chunk_offsets[%d] = {\n" % (sane_name, len(compressed_chunk_offsets)))
        for n in range(0,len(compressed_chunk_offsets)):
            gfx_source_file.write("  %4d,  // chunk %-4d // compressed size: %4d / %6.2f%%\n" % (compressed_chunk_offsets[n][0], n, compressed_chunk_offsets[n][1], (100*compressed_chunk_offsets[n][1]/chunksize)))
        gfx_source_file.write("};\n\n")

        # Write out the compressed chunk data
        gfx_source_file.write("static const uint8_t gfx_%s_chunk_data[%d] = {\n " % (sane_name, len(compressed_data)))
        count = 0
        for j in compressed_data:
            gfx_source_file.write(" 0b{0:08b}".format(j))
            count += 1
            if count < len(compressed_data):
                gfx_source_file.write(",")
                if (count % 16) == 0: # Place a new line when we reach the same number of pixels as each row
                    gfx_source_file.write("\n ")
        gfx_source_file.write("\n};\n\n")

        # Write out the image descriptor
        gfx_source_file.write("const painter_compressed_image_descriptor_t gfx_%s_compressed = {" % (sane_name))
        gfx_source_file.write("\n  .base = {")
        gfx_source_file.write("\n    .image_format = %s," % (image_format))
        gfx_source_file.write("\n    .compression  = IMAGE_COMPRESSED_LZF,")
        gfx_source_file.write("\n    .width        = %d," % (width))
        gfx_source_file.write("\n    .height       = %d" % (height))
        gfx_source_file.write("\n  },")
        gfx_source_file.write("\n  .chunk_count     = %d," % (len(compressed_chunk_offsets)))
        gfx_source_file.write("\n  .chunk_size      = %d," % (chunksize))
        gfx_source_file.write("\n  .chunk_offsets   = gfx_%s_chunk_offsets," % (sane_name))
        gfx_source_file.write("\n  .compressed_data = gfx_%s_chunk_data," % (sane_name))
        gfx_source_file.write("\n  .compressed_size = %d  // original = %d bytes (%s) / %6.2f%% of original // rgb24 = %d bytes / %6.2f%% of rgb24" % (len(compressed_data), len(graphic_data), format_name, (100*len(compressed_data)/len(graphic_data)), (3*width*height), (100*len(compressed_data)/(3*width*height))))
        gfx_source_file.write("\n};\n\n")
        gfx_source_file.write("painter_image_t gfx_%s = (painter_image_t)&gfx_%s_compressed;\n\n" % (sane_name, sane_name))

    else:
        # Generate image data lookup table
        gfx_source_file.write("static const uint8_t gfx_%s_data[%d] = {\n " % (sane_name, len(graphic_data)))
        count = 0
        for j in graphic_data:
            gfx_source_file.write(" 0b{0:08b}".format(j))
            count += 1
            if count < len(graphic_data):
                gfx_source_file.write(",")
                if (count % newline_counter) == 0: # Place a new line when we reach the same number of pixels as each row
                    gfx_source_file.write("\n ")
        gfx_source_file.write("\n};\n\n")

        # Write out the image descriptor
        gfx_source_file.write("const painter_raw_image_descriptor_t gfx_%s_raw = {" % (sane_name))
        gfx_source_file.write("\n  .base = {")
        gfx_source_file.write("\n    .image_format = %s," % (image_format))
        gfx_source_file.write("\n    .compression  = IMAGE_UNCOMPRESSED,")
        gfx_source_file.write("\n    .width        = %d," % (width))
        gfx_source_file.write("\n    .height       = %d" % (height))
        gfx_source_file.write("\n  },")
        gfx_source_file.write("\n  .byte_count   = %d," % (len(graphic_data)))
        gfx_source_file.write("\n  .image_data   = gfx_%s_data," % (sane_name))
        gfx_source_file.write("\n};\n\n")
        gfx_source_file.write("painter_image_t gfx_%s = (painter_image_t)&gfx_%s_raw;\n\n" % (sane_name, sane_name))

    gfx_source_file.write("// clang-format on\n")
    gfx_source_file.close()

    # Generate the C header file
    gfx_header_file = open(gfx_header_filename, "w")
    gfx_header_file.write(fileHeader)
    gfx_header_file.write("/* generated from %s */\n\n" % (graphic_fname))
    gfx_header_file.write("#pragma once\n\n")
    gfx_header_file.write("#include <qp.h>\n\n")
    gfx_header_file.write("extern painter_image_t gfx_%s;\n" % (sane_name))
    gfx_header_file.close()

def main():
    global args
    parser = argparse.ArgumentParser(description="Convert images to RGB565, 1bpp, 2bpp, or 4bpp for QMK Firmware's quantum_painter")
    parser.add_argument('-o',  '--output',       help="The output file name",             type=str,  required=True)
    parser.add_argument('-c',  '--compress',     help="Compresses the output using LZF",             dest="compress",   action="store_true")
    parser.add_argument('-k',  '--chunk-size',   help="The compression chunk size",       type=int,  dest="chunksize")
    parser.set_defaults(compress=False)
    parser.set_defaults(chunksize=128)

    group_fmt = parser.add_mutually_exclusive_group(required=True)
    group_fmt.add_argument('-r',  '--rgb565',    help="Output format of RGB565",          dest="fmt_rgb565", action="store_true")
    group_fmt.add_argument('-4',  '--4bpp',      help="Output format of monochrome 4bpp", dest="fmt_4bpp",   action="store_true")
    group_fmt.add_argument('-2',  '--2bpp',      help="Output format of monochrome 2bpp", dest="fmt_2bpp",   action="store_true")
    group_fmt.add_argument('-1',  '--1bpp',      help="Output format of monochrome 1bpp", dest="fmt_1bpp",   action="store_true")
    group_fmt.set_defaults(fmt_rgb565=False)
    group_fmt.set_defaults(fmt_4bpp=False)
    group_fmt.set_defaults(fmt_2bpp=False)
    group_fmt.set_defaults(fmt_1bpp=False)

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-i',  '--image-file',   type=str, help="The image file to use")

    args, unknown = parser.parse_known_args()

    if args.image_file:

        # Check image file actually exists
        if not os.path.exists(args.image_file):
            print("Can't find file %s" % (args.image_file))
            sys.exit(1)

        convert_graphic_to_c(args.image_file, args.output, args.compress, args.chunksize, args.fmt_rgb565, args.fmt_4bpp, args.fmt_2bpp, args.fmt_1bpp)

if __name__ == "__main__":
    main()
